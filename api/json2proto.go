package json2protobuff

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"regexp"
	"strings"
	"text/template"

	"github.com/emicklei/proto"
	"gitter.top/common/goref"
	"gitter.top/common/protofmt"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Entry struct {
	Name     string `json:"name,omitempty"`
	Type     string `json:"type,omitempty"`
	Repeated bool   `json:"repeated,omitempty"`
}

type Message struct {
	SubMessage map[string]*Message `json:"sub_message,omitempty"`
	Entries    []*Entry            `json:"entries,omitempty"`
}

type Parser struct {
	FileHeaderDefinition bool
	TiledDefinition      bool
	MergeMessage         bool
	_data                map[string]interface{}
	_rawMessage          *Message
	_tiledMessage        *Message
}
type Option func(Parser *Parser)

func WithTiledMessage(isTiled bool) func(parser *Parser) {
	return func(parser *Parser) {
		parser.TiledDefinition = isTiled
	}
}

func WithMergeMessage(isMerge bool) func(parser *Parser) {
	return func(parser *Parser) {
		parser.MergeMessage = isMerge
	}
}

func WithShowFileHeader(isShow bool) func(parser *Parser) {
	return func(parser *Parser) {
		parser.FileHeaderDefinition = isShow
	}
}
func NewParser(reader io.Reader, options ...Option) (*Parser, error) {
	buffer, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	if !json.Valid(buffer) {
		return nil, fmt.Errorf("ivalid json format")
	}
	parser := &Parser{
		_data:         make(map[string]interface{}),
		_rawMessage:   &Message{SubMessage: make(map[string]*Message)},
		_tiledMessage: &Message{SubMessage: make(map[string]*Message)},
	}
	for _, option := range options {
		option(parser)
	}
	if err := json.Unmarshal(buffer, &parser._data); err != nil {
		return nil, err
	}
	return parser, nil
}
func (p *Parser) parse(valueOf interface{}) *Message {
	vo := reflect.ValueOf(valueOf)
	if vo.IsZero() {
		return nil
	}
	if vo.Kind() == reflect.Ptr {
		vo = vo.Elem()
	}
	if vo.Kind() == reflect.Map {
		p._rawMessage = p.rangeItem(vo.MapRange())
	}
	return nil
}

func (p *Parser) Parse() error {
	p.parse(p._data)
	return nil
}

func (p *Parser) rangeItem(mapIter *reflect.MapIter) *Message {
	if mapIter == nil {
		return nil
	}
	var msg = &Message{SubMessage: make(map[string]*Message)}
	for mapIter.Next() {
		var fd = new(Entry)
		fd.Name = mapIter.Key().String()
		value := mapIter.Value()
		if value.Kind() == reflect.Ptr {
			value = value.Elem()
		}
		if value.Kind() == reflect.Interface {
			value = reflect.ValueOf(value.Interface())
		}
		switch value.Kind() {
		case reflect.String:
			fd.Type = "string"
		case reflect.Bool:
			fd.Type = "bool"
		case reflect.Float32:
			fd.Type = "float"
		case reflect.Float64:
			// Handle JSON numbers - default to sint32 for integers
			f := value.Float()
			if f == float64(int32(f)) {
				fd.Type = "sint32"
			} else {
				fd.Type = "double"
			}
		case reflect.Map:
			fd.Type = ConvertSnakeCaseToUpperCamelCase(fd.Name)
			m := p.rangeItem(value.MapRange())
			msg.SubMessage[fd.Type] = m
		case reflect.Slice, reflect.Array:
			fd.Repeated = true
			size := value.Len()
			if size == 0 {
				fd.Type = "google.protobuf.Any"
			} else {
				vi := value.Index(0).Interface()
				if goref.IsBasicType(vi) {
					fd.Type = GoType2ProtoType(reflect.ValueOf(vi).Type().Kind())
				} else {
					fd.Type = ConvertSnakeCaseToUpperCamelCase(fd.Name)
					m := p.rangeItem(reflect.ValueOf(vi).MapRange())
					msg.SubMessage[fd.Type] = m
				}
			}
		case reflect.Invalid:
			fd.Type = "google.protobuf.Any"
		default:
			fmt.Printf("Unhandled type - key: %s, type: %s, value: %v\n",
				fd.Name, value.Kind().String(), mapIter.Value())
		}

		msg.Entries = append(msg.Entries, fd)
	}
	return msg
}

const (
	FileHeaderTemplate = `syntax = "proto3"
	
package your.project.v1;

option go_package = "your/project;projectv1";
`
	// TiledTemplate: all messages at root level
	TiledTemplate = `{{range $name, $message := .SubMessage}}message {{$name}} {
	{{range $idx, $field := $message.Entries}}{{if $field.Repeated}}repeated {{end}}{{$field.Type}} {{$field.Name}} = {{add $idx 1}};
	{{end}}
	}
	{{end}}
	message AutoGenerated {
	{{range $idx, $field := .Entries}}{{if $field.Repeated}}repeated {{end}}{{$field.Type}} {{$field.Name}} = {{add $idx 1}};
	{{end}}
	}`

	// EmbedTemplate: nested message style
	EmbedTemplate = `message AutoGenerated {
		{{range $name, $message := .SubMessage}}message {{$name}} {
	{{range $idx, $field := $message.Entries}}{{if $field.Repeated}}repeated {{end}}{{$field.Type}} {{$field.Name}} = {{add $idx 1}};
	{{end}}
	}
	{{end}}
	{{range $idx, $field := .Entries}}{{if $field.Repeated}}repeated {{end}}{{$field.Type}} {{$field.Name}} = {{add $idx 1}};
	{{end}}
	}`
)

func Add(x, y int) int {
	return x + y
}
func (p *Parser) ProtobufTemplateRender(tpl string) (io.ReadWriter, error) {
	if p.FileHeaderDefinition {
		tpl = FileHeaderTemplate + tpl
	}
	tmpl, err := template.New("file_template").Funcs(template.FuncMap{"add": Add}).Parse(tpl)
	if err != nil {
		return nil, err
	}
	if err := p.tiled(p._rawMessage.SubMessage); err != nil {
		return nil, err
	}
	p._tiledMessage.Entries = p._rawMessage.Entries
	if err := p.validName(p._tiledMessage); err != nil {
		return nil, err
	}
	var buffer = new(bytes.Buffer)
	err = tmpl.Execute(buffer, p._tiledMessage)
	if err != nil {
		return nil, err
	}
	return buffer, nil
}

func (p *Parser) format2Proto(buf io.ReadWriter) string {
	pb := proto.NewParser(buf)
	parse, err := pb.Parse()
	if err != nil {
		return err.Error()
	}
	protofmt.NewFormatter(buf, "   ").Format(parse)
	var buff bytes.Buffer
	_, _ = buff.ReadFrom(buf)
	return buff.String()

}

func (p *Parser) Output() string {
	var tpl = EmbedTemplate
	if p.TiledDefinition {
		tpl = TiledTemplate
	}
	writer, err := p.ProtobufTemplateRender(tpl)
	if err != nil {
		return err.Error()
	}
	return p.format2Proto(writer)
}

func (p *Parser) tiled(messages map[string]*Message) error {
	if len(messages) == 0 {
		return nil
	}
	for name, message := range messages {
		if err := p.tiled(message.SubMessage); err != nil {
			return err
		}
		old, exist := p._tiledMessage.SubMessage[name]
		if !exist {
			p._tiledMessage.SubMessage[name] = message
			continue
		}
		mergeFields, err := p.merge(message, old)
		if err != nil {
			return err
		}
		p._tiledMessage.SubMessage[name].Entries = mergeFields
	}
	return nil
}
func (p *Parser) merge(a, b *Message) ([]*Entry, error) {
	var fieldMap = make(map[string]*Entry)
	for _, field := range a.Entries {
		fieldMap[field.Name] = field
	}
	for _, field := range b.Entries {
		old, exist := fieldMap[field.Name]
		if !exist {
			fieldMap[field.Name] = field
			continue
		}
		if field.Repeated != old.Repeated {
			return nil, fmt.Errorf("conflect field %s on repeated attribute", old.Name)
		}
		if field.Type != old.Type {
			return nil, fmt.Errorf("conflect field %s on type attribute", old.Type)
		}
	}
	var newFields []*Entry
	for _, field := range fieldMap {
		newFields = append(newFields, field)
	}
	return newFields, nil
}

func ConvertSnakeCaseToUpperCamelCase(str string) string {
	str = strings.Replace(str, "_", " ", -1)
	str = cases.Title(language.English).String(str)
	return strings.Replace(str, " ", "", -1)
}
func validateFieldName(fieldName string) bool {
	if len(fieldName) == 0 {
		return false
	}
	re := regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_]*$`)
	return re.MatchString(fieldName)
}

func (p *Parser) validName(raw *Message) error {

	for _, field := range raw.Entries {
		if !validateFieldName(field.Name) {
			return fmt.Errorf("invalid field name %s", field.Name)
		}
	}

	for mName, message := range raw.SubMessage {
		if !validateFieldName(mName) {
			return fmt.Errorf("invalid field name %s", mName)
		}
		for _, field := range message.Entries {
			if !validateFieldName(field.Name) {
				return fmt.Errorf("invalid field name %s.%s", mName, field.Name)
			}
		}
	}
	return nil
}
func GoType2ProtoType(to reflect.Kind) string {
	switch to {
	case reflect.Int8, reflect.Int16, reflect.Int32:
		return "sint32"
	case reflect.Int, reflect.Int64:
		return "sint64"
	case reflect.Uint8, reflect.Uint16, reflect.Uint32:
		return "fixed32"
	case reflect.Uint, reflect.Uint64:
		return "fixed64"
	case reflect.Bool:
		return "bool"
	case reflect.String:
		return "string"
	case reflect.Float32:
		return "float"
	case reflect.Float64:
		return "double"
	default:
		panic("invalid type: " + to.String())
	}
}

func WebHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		responseFailed(w, fmt.Errorf("method not allowed: %s", r.Method))
		return
	}

	body, err := io.ReadAll(r.Body)
	if err != nil {
		responseFailed(w, err)
		return
	}
	reader := bytes.NewReader(body)
	parser, err := NewParser(reader, WithShowFileHeader(true),
		WithMergeMessage(true),
		WithTiledMessage(false))
	if err != nil {
		responseFailed(w, err)
		return
	}

	err = parser.Parse()
	if err != nil {
		responseFailed(w, err)
		return
	}
	responeOK(w, parser.Output())
}

func responeOK(w http.ResponseWriter, output string) {
	w.WriteHeader(http.StatusOK)
	w.Header().Set("content-Type", "text/plain")
	_, _ = w.Write([]byte(output))
}

func responseFailed(w http.ResponseWriter, err error) {
	w.WriteHeader(http.StatusBadRequest)
	w.Header().Set("content-Type", "text/plain")
	_, _ = w.Write([]byte("bad request: " + err.Error()))
}
